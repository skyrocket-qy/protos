// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: authzpb/v1/authz.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../google/protobuf/empty";
import { Timestamp } from "../../google/protobuf/timestamp";
import { Filter, Pager, Sorter } from "../../pkgpb/v1/pkg";

export const protobufPackage = "authzpb.v1";

export interface Tuple {
  sbjNs: string;
  sbjId: string;
  rel: string;
  objNs: string;
  objId: string;
}

export interface TupleFilter {
  sbjNs?: string | undefined;
  sbjId?: string | undefined;
  rel?: string | undefined;
  objNs?: string | undefined;
  objId?: string | undefined;
}

export interface ListTuplesIn {
  /** created_at, email, name, is_email_confirmed, is_active, auth_type, org_name */
  filters: Filter[];
  /** created_at, auth_type, org_name */
  sorters: Sorter[];
  pager: Pager | undefined;
}

export interface ListTuplesOut {
  tuples: Tuple[];
  total: number;
}

export interface Instance {
  ns: string;
  name: string;
}

export interface TreeNode {
  root: Instance | undefined;
  children: { [key: string]: TreeNode };
}

export interface TreeNode_ChildrenEntry {
  key: string;
  value: TreeNode | undefined;
}

export interface Org {
  id: number;
  name: string;
}

export interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
  isEmailConfirmed: boolean;
  authTypes: string[];
  orgs: string[];
  createdAt: Date | undefined;
}

export interface UpdateUserIn {
  id: number;
  name?: string | undefined;
  isActive?: boolean | undefined;
}

export interface Role {
  id: number;
  name: string;
}

export interface Resource {
  id: number;
  ns: string;
  name: string;
}

export interface ListUsersIn {
  /** created_at, email, name, is_email_confirmed, is_active, auth_type, org_name */
  filters: Filter[];
  /** created_at, auth_type, org_name */
  sorters: Sorter[];
  pager: Pager | undefined;
}

export interface ListUsersOut {
  users: User[];
  count: number;
}

export interface DeleteUserIn {
  id: number;
}

export interface CreateRoleIn {
  name: string;
}

export interface ListRolesIn {
  /** created_at, email, name, is_email_confirmed, is_active, auth_type, org_name */
  filters: Filter[];
  /** created_at, auth_type, org_name */
  sorters: Sorter[];
  pager: Pager | undefined;
}

export interface ListRolesOut {
  roles: Role[];
  total: number;
}

export interface UpdateRoleIn {
  id: number;
  name: string;
}

export interface DeleteRoleIn {
  id: number;
}

export interface ListResourcesIn {
  /** created_at, email, name, is_email_confirmed, is_active, auth_type, org_name */
  filters: Filter[];
  /** created_at, auth_type, org_name */
  sorters: Sorter[];
  pager: Pager | undefined;
}

export interface ListResourcesOut {
  resources: Resource[];
  total: number;
}

export interface CreateResourceIn {
  ns: string;
  name: string;
}

export interface DeleteResourceIn {
  id: number;
}

export interface AssignRoleIn {
  roleId: number;
  userId: number;
}

export interface RevokeRoleIn {
  roleId: number;
  userId: number;
}

export interface GrantPermIn {
  roleId: number;
  perm: string;
  resourceId: number;
}

export interface RevokePermIn {
  roleId: number;
  perm: string;
  resourceId: number;
}

function createBaseTuple(): Tuple {
  return { sbjNs: "", sbjId: "", rel: "", objNs: "", objId: "" };
}

export const Tuple: MessageFns<Tuple> = {
  encode(message: Tuple, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sbjNs !== "") {
      writer.uint32(10).string(message.sbjNs);
    }
    if (message.sbjId !== "") {
      writer.uint32(18).string(message.sbjId);
    }
    if (message.rel !== "") {
      writer.uint32(26).string(message.rel);
    }
    if (message.objNs !== "") {
      writer.uint32(34).string(message.objNs);
    }
    if (message.objId !== "") {
      writer.uint32(42).string(message.objId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tuple {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuple();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sbjNs = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sbjId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objNs = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.objId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tuple {
    return {
      sbjNs: isSet(object.sbjNs) ? globalThis.String(object.sbjNs) : "",
      sbjId: isSet(object.sbjId) ? globalThis.String(object.sbjId) : "",
      rel: isSet(object.rel) ? globalThis.String(object.rel) : "",
      objNs: isSet(object.objNs) ? globalThis.String(object.objNs) : "",
      objId: isSet(object.objId) ? globalThis.String(object.objId) : "",
    };
  },

  toJSON(message: Tuple): unknown {
    const obj: any = {};
    if (message.sbjNs !== "") {
      obj.sbjNs = message.sbjNs;
    }
    if (message.sbjId !== "") {
      obj.sbjId = message.sbjId;
    }
    if (message.rel !== "") {
      obj.rel = message.rel;
    }
    if (message.objNs !== "") {
      obj.objNs = message.objNs;
    }
    if (message.objId !== "") {
      obj.objId = message.objId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tuple>, I>>(base?: I): Tuple {
    return Tuple.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tuple>, I>>(object: I): Tuple {
    const message = createBaseTuple();
    message.sbjNs = object.sbjNs ?? "";
    message.sbjId = object.sbjId ?? "";
    message.rel = object.rel ?? "";
    message.objNs = object.objNs ?? "";
    message.objId = object.objId ?? "";
    return message;
  },
};

function createBaseTupleFilter(): TupleFilter {
  return { sbjNs: undefined, sbjId: undefined, rel: undefined, objNs: undefined, objId: undefined };
}

export const TupleFilter: MessageFns<TupleFilter> = {
  encode(message: TupleFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sbjNs !== undefined) {
      writer.uint32(10).string(message.sbjNs);
    }
    if (message.sbjId !== undefined) {
      writer.uint32(18).string(message.sbjId);
    }
    if (message.rel !== undefined) {
      writer.uint32(26).string(message.rel);
    }
    if (message.objNs !== undefined) {
      writer.uint32(34).string(message.objNs);
    }
    if (message.objId !== undefined) {
      writer.uint32(42).string(message.objId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TupleFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTupleFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sbjNs = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sbjId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objNs = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.objId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TupleFilter {
    return {
      sbjNs: isSet(object.sbjNs) ? globalThis.String(object.sbjNs) : undefined,
      sbjId: isSet(object.sbjId) ? globalThis.String(object.sbjId) : undefined,
      rel: isSet(object.rel) ? globalThis.String(object.rel) : undefined,
      objNs: isSet(object.objNs) ? globalThis.String(object.objNs) : undefined,
      objId: isSet(object.objId) ? globalThis.String(object.objId) : undefined,
    };
  },

  toJSON(message: TupleFilter): unknown {
    const obj: any = {};
    if (message.sbjNs !== undefined) {
      obj.sbjNs = message.sbjNs;
    }
    if (message.sbjId !== undefined) {
      obj.sbjId = message.sbjId;
    }
    if (message.rel !== undefined) {
      obj.rel = message.rel;
    }
    if (message.objNs !== undefined) {
      obj.objNs = message.objNs;
    }
    if (message.objId !== undefined) {
      obj.objId = message.objId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TupleFilter>, I>>(base?: I): TupleFilter {
    return TupleFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TupleFilter>, I>>(object: I): TupleFilter {
    const message = createBaseTupleFilter();
    message.sbjNs = object.sbjNs ?? undefined;
    message.sbjId = object.sbjId ?? undefined;
    message.rel = object.rel ?? undefined;
    message.objNs = object.objNs ?? undefined;
    message.objId = object.objId ?? undefined;
    return message;
  },
};

function createBaseListTuplesIn(): ListTuplesIn {
  return { filters: [], sorters: [], pager: undefined };
}

export const ListTuplesIn: MessageFns<ListTuplesIn> = {
  encode(message: ListTuplesIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.sorters) {
      Sorter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pager !== undefined) {
      Pager.encode(message.pager, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTuplesIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTuplesIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sorters.push(Sorter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pager = Pager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTuplesIn {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      sorters: globalThis.Array.isArray(object?.sorters) ? object.sorters.map((e: any) => Sorter.fromJSON(e)) : [],
      pager: isSet(object.pager) ? Pager.fromJSON(object.pager) : undefined,
    };
  },

  toJSON(message: ListTuplesIn): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.sorters?.length) {
      obj.sorters = message.sorters.map((e) => Sorter.toJSON(e));
    }
    if (message.pager !== undefined) {
      obj.pager = Pager.toJSON(message.pager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTuplesIn>, I>>(base?: I): ListTuplesIn {
    return ListTuplesIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTuplesIn>, I>>(object: I): ListTuplesIn {
    const message = createBaseListTuplesIn();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.sorters = object.sorters?.map((e) => Sorter.fromPartial(e)) || [];
    message.pager = (object.pager !== undefined && object.pager !== null) ? Pager.fromPartial(object.pager) : undefined;
    return message;
  },
};

function createBaseListTuplesOut(): ListTuplesOut {
  return { tuples: [], total: 0 };
}

export const ListTuplesOut: MessageFns<ListTuplesOut> = {
  encode(message: ListTuplesOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tuples) {
      Tuple.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTuplesOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTuplesOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tuples.push(Tuple.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTuplesOut {
    return {
      tuples: globalThis.Array.isArray(object?.tuples) ? object.tuples.map((e: any) => Tuple.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListTuplesOut): unknown {
    const obj: any = {};
    if (message.tuples?.length) {
      obj.tuples = message.tuples.map((e) => Tuple.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTuplesOut>, I>>(base?: I): ListTuplesOut {
    return ListTuplesOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTuplesOut>, I>>(object: I): ListTuplesOut {
    const message = createBaseListTuplesOut();
    message.tuples = object.tuples?.map((e) => Tuple.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseInstance(): Instance {
  return { ns: "", name: "" };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ns !== "") {
      writer.uint32(10).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ns = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTreeNode(): TreeNode {
  return { root: undefined, children: {} };
}

export const TreeNode: MessageFns<TreeNode> = {
  encode(message: TreeNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.root !== undefined) {
      Instance.encode(message.root, writer.uint32(10).fork()).join();
    }
    Object.entries(message.children).forEach(([key, value]) => {
      TreeNode_ChildrenEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.root = Instance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = TreeNode_ChildrenEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.children[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode {
    return {
      root: isSet(object.root) ? Instance.fromJSON(object.root) : undefined,
      children: isObject(object.children)
        ? Object.entries(object.children).reduce<{ [key: string]: TreeNode }>((acc, [key, value]) => {
          acc[key] = TreeNode.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: TreeNode): unknown {
    const obj: any = {};
    if (message.root !== undefined) {
      obj.root = Instance.toJSON(message.root);
    }
    if (message.children) {
      const entries = Object.entries(message.children);
      if (entries.length > 0) {
        obj.children = {};
        entries.forEach(([k, v]) => {
          obj.children[k] = TreeNode.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeNode>, I>>(base?: I): TreeNode {
    return TreeNode.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeNode>, I>>(object: I): TreeNode {
    const message = createBaseTreeNode();
    message.root = (object.root !== undefined && object.root !== null) ? Instance.fromPartial(object.root) : undefined;
    message.children = Object.entries(object.children ?? {}).reduce<{ [key: string]: TreeNode }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = TreeNode.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseTreeNode_ChildrenEntry(): TreeNode_ChildrenEntry {
  return { key: "", value: undefined };
}

export const TreeNode_ChildrenEntry: MessageFns<TreeNode_ChildrenEntry> = {
  encode(message: TreeNode_ChildrenEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      TreeNode.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TreeNode_ChildrenEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTreeNode_ChildrenEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = TreeNode.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TreeNode_ChildrenEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? TreeNode.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TreeNode_ChildrenEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = TreeNode.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TreeNode_ChildrenEntry>, I>>(base?: I): TreeNode_ChildrenEntry {
    return TreeNode_ChildrenEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TreeNode_ChildrenEntry>, I>>(object: I): TreeNode_ChildrenEntry {
    const message = createBaseTreeNode_ChildrenEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? TreeNode.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseOrg(): Org {
  return { id: 0, name: "" };
}

export const Org: MessageFns<Org> = {
  encode(message: Org, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Org {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Org {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Org): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Org>, I>>(base?: I): Org {
    return Org.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Org>, I>>(object: I): Org {
    const message = createBaseOrg();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: 0,
    name: "",
    email: "",
    isActive: false,
    isEmailConfirmed: false,
    authTypes: [],
    orgs: [],
    createdAt: undefined,
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.isActive !== false) {
      writer.uint32(32).bool(message.isActive);
    }
    if (message.isEmailConfirmed !== false) {
      writer.uint32(40).bool(message.isEmailConfirmed);
    }
    for (const v of message.authTypes) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.orgs) {
      writer.uint32(58).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isEmailConfirmed = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.authTypes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.orgs.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      isEmailConfirmed: isSet(object.isEmailConfirmed) ? globalThis.Boolean(object.isEmailConfirmed) : false,
      authTypes: globalThis.Array.isArray(object?.authTypes)
        ? object.authTypes.map((e: any) => globalThis.String(e))
        : [],
      orgs: globalThis.Array.isArray(object?.orgs) ? object.orgs.map((e: any) => globalThis.String(e)) : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.isEmailConfirmed !== false) {
      obj.isEmailConfirmed = message.isEmailConfirmed;
    }
    if (message.authTypes?.length) {
      obj.authTypes = message.authTypes;
    }
    if (message.orgs?.length) {
      obj.orgs = message.orgs;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.email = object.email ?? "";
    message.isActive = object.isActive ?? false;
    message.isEmailConfirmed = object.isEmailConfirmed ?? false;
    message.authTypes = object.authTypes?.map((e) => e) || [];
    message.orgs = object.orgs?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseUpdateUserIn(): UpdateUserIn {
  return { id: 0, name: undefined, isActive: undefined };
}

export const UpdateUserIn: MessageFns<UpdateUserIn> = {
  encode(message: UpdateUserIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.isActive !== undefined) {
      writer.uint32(24).bool(message.isActive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateUserIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateUserIn {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : undefined,
    };
  },

  toJSON(message: UpdateUserIn): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.isActive !== undefined) {
      obj.isActive = message.isActive;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateUserIn>, I>>(base?: I): UpdateUserIn {
    return UpdateUserIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateUserIn>, I>>(object: I): UpdateUserIn {
    const message = createBaseUpdateUserIn();
    message.id = object.id ?? 0;
    message.name = object.name ?? undefined;
    message.isActive = object.isActive ?? undefined;
    return message;
  },
};

function createBaseRole(): Role {
  return { id: 0, name: "" };
}

export const Role: MessageFns<Role> = {
  encode(message: Role, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Role {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Role {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Role): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Role>, I>>(base?: I): Role {
    return Role.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Role>, I>>(object: I): Role {
    const message = createBaseRole();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResource(): Resource {
  return { id: 0, ns: "", name: "" };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.ns !== "") {
      writer.uint32(18).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ns = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resource>, I>>(base?: I): Resource {
    return Resource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resource>, I>>(object: I): Resource {
    const message = createBaseResource();
    message.id = object.id ?? 0;
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListUsersIn(): ListUsersIn {
  return { filters: [], sorters: [], pager: undefined };
}

export const ListUsersIn: MessageFns<ListUsersIn> = {
  encode(message: ListUsersIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.sorters) {
      Sorter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pager !== undefined) {
      Pager.encode(message.pager, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sorters.push(Sorter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pager = Pager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersIn {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      sorters: globalThis.Array.isArray(object?.sorters) ? object.sorters.map((e: any) => Sorter.fromJSON(e)) : [],
      pager: isSet(object.pager) ? Pager.fromJSON(object.pager) : undefined,
    };
  },

  toJSON(message: ListUsersIn): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.sorters?.length) {
      obj.sorters = message.sorters.map((e) => Sorter.toJSON(e));
    }
    if (message.pager !== undefined) {
      obj.pager = Pager.toJSON(message.pager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersIn>, I>>(base?: I): ListUsersIn {
    return ListUsersIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersIn>, I>>(object: I): ListUsersIn {
    const message = createBaseListUsersIn();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.sorters = object.sorters?.map((e) => Sorter.fromPartial(e)) || [];
    message.pager = (object.pager !== undefined && object.pager !== null) ? Pager.fromPartial(object.pager) : undefined;
    return message;
  },
};

function createBaseListUsersOut(): ListUsersOut {
  return { users: [], count: 0 };
}

export const ListUsersOut: MessageFns<ListUsersOut> = {
  encode(message: ListUsersOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListUsersOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListUsersOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListUsersOut {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ListUsersOut): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListUsersOut>, I>>(base?: I): ListUsersOut {
    return ListUsersOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListUsersOut>, I>>(object: I): ListUsersOut {
    const message = createBaseListUsersOut();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseDeleteUserIn(): DeleteUserIn {
  return { id: 0 };
}

export const DeleteUserIn: MessageFns<DeleteUserIn> = {
  encode(message: DeleteUserIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteUserIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteUserIn {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteUserIn): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteUserIn>, I>>(base?: I): DeleteUserIn {
    return DeleteUserIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteUserIn>, I>>(object: I): DeleteUserIn {
    const message = createBaseDeleteUserIn();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseCreateRoleIn(): CreateRoleIn {
  return { name: "" };
}

export const CreateRoleIn: MessageFns<CreateRoleIn> = {
  encode(message: CreateRoleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoleIn {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreateRoleIn): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRoleIn>, I>>(base?: I): CreateRoleIn {
    return CreateRoleIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRoleIn>, I>>(object: I): CreateRoleIn {
    const message = createBaseCreateRoleIn();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRolesIn(): ListRolesIn {
  return { filters: [], sorters: [], pager: undefined };
}

export const ListRolesIn: MessageFns<ListRolesIn> = {
  encode(message: ListRolesIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.sorters) {
      Sorter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pager !== undefined) {
      Pager.encode(message.pager, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sorters.push(Sorter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pager = Pager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesIn {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      sorters: globalThis.Array.isArray(object?.sorters) ? object.sorters.map((e: any) => Sorter.fromJSON(e)) : [],
      pager: isSet(object.pager) ? Pager.fromJSON(object.pager) : undefined,
    };
  },

  toJSON(message: ListRolesIn): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.sorters?.length) {
      obj.sorters = message.sorters.map((e) => Sorter.toJSON(e));
    }
    if (message.pager !== undefined) {
      obj.pager = Pager.toJSON(message.pager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRolesIn>, I>>(base?: I): ListRolesIn {
    return ListRolesIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRolesIn>, I>>(object: I): ListRolesIn {
    const message = createBaseListRolesIn();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.sorters = object.sorters?.map((e) => Sorter.fromPartial(e)) || [];
    message.pager = (object.pager !== undefined && object.pager !== null) ? Pager.fromPartial(object.pager) : undefined;
    return message;
  },
};

function createBaseListRolesOut(): ListRolesOut {
  return { roles: [], total: 0 };
}

export const ListRolesOut: MessageFns<ListRolesOut> = {
  encode(message: ListRolesOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRolesOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRolesOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRolesOut {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => Role.fromJSON(e)) : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListRolesOut): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => Role.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRolesOut>, I>>(base?: I): ListRolesOut {
    return ListRolesOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRolesOut>, I>>(object: I): ListRolesOut {
    const message = createBaseListRolesOut();
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseUpdateRoleIn(): UpdateRoleIn {
  return { id: 0, name: "" };
}

export const UpdateRoleIn: MessageFns<UpdateRoleIn> = {
  encode(message: UpdateRoleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRoleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoleIn {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: UpdateRoleIn): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRoleIn>, I>>(base?: I): UpdateRoleIn {
    return UpdateRoleIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRoleIn>, I>>(object: I): UpdateRoleIn {
    const message = createBaseUpdateRoleIn();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteRoleIn(): DeleteRoleIn {
  return { id: 0 };
}

export const DeleteRoleIn: MessageFns<DeleteRoleIn> = {
  encode(message: DeleteRoleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoleIn {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteRoleIn): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRoleIn>, I>>(base?: I): DeleteRoleIn {
    return DeleteRoleIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRoleIn>, I>>(object: I): DeleteRoleIn {
    const message = createBaseDeleteRoleIn();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseListResourcesIn(): ListResourcesIn {
  return { filters: [], sorters: [], pager: undefined };
}

export const ListResourcesIn: MessageFns<ListResourcesIn> = {
  encode(message: ListResourcesIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.sorters) {
      Sorter.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.pager !== undefined) {
      Pager.encode(message.pager, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListResourcesIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResourcesIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sorters.push(Sorter.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pager = Pager.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListResourcesIn {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
      sorters: globalThis.Array.isArray(object?.sorters) ? object.sorters.map((e: any) => Sorter.fromJSON(e)) : [],
      pager: isSet(object.pager) ? Pager.fromJSON(object.pager) : undefined,
    };
  },

  toJSON(message: ListResourcesIn): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    if (message.sorters?.length) {
      obj.sorters = message.sorters.map((e) => Sorter.toJSON(e));
    }
    if (message.pager !== undefined) {
      obj.pager = Pager.toJSON(message.pager);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListResourcesIn>, I>>(base?: I): ListResourcesIn {
    return ListResourcesIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListResourcesIn>, I>>(object: I): ListResourcesIn {
    const message = createBaseListResourcesIn();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    message.sorters = object.sorters?.map((e) => Sorter.fromPartial(e)) || [];
    message.pager = (object.pager !== undefined && object.pager !== null) ? Pager.fromPartial(object.pager) : undefined;
    return message;
  },
};

function createBaseListResourcesOut(): ListResourcesOut {
  return { resources: [], total: 0 };
}

export const ListResourcesOut: MessageFns<ListResourcesOut> = {
  encode(message: ListResourcesOut, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      Resource.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(16).int64(message.total);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListResourcesOut {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListResourcesOut();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resources.push(Resource.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListResourcesOut {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Resource.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
    };
  },

  toJSON(message: ListResourcesOut): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Resource.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListResourcesOut>, I>>(base?: I): ListResourcesOut {
    return ListResourcesOut.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListResourcesOut>, I>>(object: I): ListResourcesOut {
    const message = createBaseListResourcesOut();
    message.resources = object.resources?.map((e) => Resource.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    return message;
  },
};

function createBaseCreateResourceIn(): CreateResourceIn {
  return { ns: "", name: "" };
}

export const CreateResourceIn: MessageFns<CreateResourceIn> = {
  encode(message: CreateResourceIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ns !== "") {
      writer.uint32(10).string(message.ns);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateResourceIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateResourceIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ns = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateResourceIn {
    return {
      ns: isSet(object.ns) ? globalThis.String(object.ns) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: CreateResourceIn): unknown {
    const obj: any = {};
    if (message.ns !== "") {
      obj.ns = message.ns;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateResourceIn>, I>>(base?: I): CreateResourceIn {
    return CreateResourceIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateResourceIn>, I>>(object: I): CreateResourceIn {
    const message = createBaseCreateResourceIn();
    message.ns = object.ns ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteResourceIn(): DeleteResourceIn {
  return { id: 0 };
}

export const DeleteResourceIn: MessageFns<DeleteResourceIn> = {
  encode(message: DeleteResourceIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResourceIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResourceIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResourceIn {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteResourceIn): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResourceIn>, I>>(base?: I): DeleteResourceIn {
    return DeleteResourceIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResourceIn>, I>>(object: I): DeleteResourceIn {
    const message = createBaseDeleteResourceIn();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseAssignRoleIn(): AssignRoleIn {
  return { roleId: 0, userId: 0 };
}

export const AssignRoleIn: MessageFns<AssignRoleIn> = {
  encode(message: AssignRoleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== 0) {
      writer.uint32(8).uint64(message.roleId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignRoleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignRoleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roleId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignRoleIn {
    return {
      roleId: isSet(object.roleId) ? globalThis.Number(object.roleId) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: AssignRoleIn): unknown {
    const obj: any = {};
    if (message.roleId !== 0) {
      obj.roleId = Math.round(message.roleId);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignRoleIn>, I>>(base?: I): AssignRoleIn {
    return AssignRoleIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignRoleIn>, I>>(object: I): AssignRoleIn {
    const message = createBaseAssignRoleIn();
    message.roleId = object.roleId ?? 0;
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseRevokeRoleIn(): RevokeRoleIn {
  return { roleId: 0, userId: 0 };
}

export const RevokeRoleIn: MessageFns<RevokeRoleIn> = {
  encode(message: RevokeRoleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== 0) {
      writer.uint32(8).uint64(message.roleId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeRoleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeRoleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roleId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeRoleIn {
    return {
      roleId: isSet(object.roleId) ? globalThis.Number(object.roleId) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: RevokeRoleIn): unknown {
    const obj: any = {};
    if (message.roleId !== 0) {
      obj.roleId = Math.round(message.roleId);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokeRoleIn>, I>>(base?: I): RevokeRoleIn {
    return RevokeRoleIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokeRoleIn>, I>>(object: I): RevokeRoleIn {
    const message = createBaseRevokeRoleIn();
    message.roleId = object.roleId ?? 0;
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseGrantPermIn(): GrantPermIn {
  return { roleId: 0, perm: "", resourceId: 0 };
}

export const GrantPermIn: MessageFns<GrantPermIn> = {
  encode(message: GrantPermIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== 0) {
      writer.uint32(8).uint64(message.roleId);
    }
    if (message.perm !== "") {
      writer.uint32(18).string(message.perm);
    }
    if (message.resourceId !== 0) {
      writer.uint32(24).uint64(message.resourceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrantPermIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrantPermIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roleId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.perm = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resourceId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrantPermIn {
    return {
      roleId: isSet(object.roleId) ? globalThis.Number(object.roleId) : 0,
      perm: isSet(object.perm) ? globalThis.String(object.perm) : "",
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: GrantPermIn): unknown {
    const obj: any = {};
    if (message.roleId !== 0) {
      obj.roleId = Math.round(message.roleId);
    }
    if (message.perm !== "") {
      obj.perm = message.perm;
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GrantPermIn>, I>>(base?: I): GrantPermIn {
    return GrantPermIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GrantPermIn>, I>>(object: I): GrantPermIn {
    const message = createBaseGrantPermIn();
    message.roleId = object.roleId ?? 0;
    message.perm = object.perm ?? "";
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

function createBaseRevokePermIn(): RevokePermIn {
  return { roleId: 0, perm: "", resourceId: 0 };
}

export const RevokePermIn: MessageFns<RevokePermIn> = {
  encode(message: RevokePermIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roleId !== 0) {
      writer.uint32(8).uint64(message.roleId);
    }
    if (message.perm !== "") {
      writer.uint32(18).string(message.perm);
    }
    if (message.resourceId !== 0) {
      writer.uint32(24).uint64(message.resourceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokePermIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokePermIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roleId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.perm = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resourceId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokePermIn {
    return {
      roleId: isSet(object.roleId) ? globalThis.Number(object.roleId) : 0,
      perm: isSet(object.perm) ? globalThis.String(object.perm) : "",
      resourceId: isSet(object.resourceId) ? globalThis.Number(object.resourceId) : 0,
    };
  },

  toJSON(message: RevokePermIn): unknown {
    const obj: any = {};
    if (message.roleId !== 0) {
      obj.roleId = Math.round(message.roleId);
    }
    if (message.perm !== "") {
      obj.perm = message.perm;
    }
    if (message.resourceId !== 0) {
      obj.resourceId = Math.round(message.resourceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RevokePermIn>, I>>(base?: I): RevokePermIn {
    return RevokePermIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RevokePermIn>, I>>(object: I): RevokePermIn {
    const message = createBaseRevokePermIn();
    message.roleId = object.roleId ?? 0;
    message.perm = object.perm ?? "";
    message.resourceId = object.resourceId ?? 0;
    return message;
  },
};

export interface AuthzService {
  ListUsers(request: ListUsersIn): Promise<ListUsersOut>;
  UpdateUser(request: UpdateUserIn): Promise<Empty>;
  DeleteUser(request: DeleteUserIn): Promise<Empty>;
  CreateRole(request: CreateRoleIn): Promise<Empty>;
  ListRoles(request: ListRolesIn): Promise<ListRolesOut>;
  UpdateRole(request: UpdateRoleIn): Promise<Empty>;
  DeleteRole(request: DeleteRoleIn): Promise<Empty>;
  CreateResource(request: CreateResourceIn): Promise<Empty>;
  ListResources(request: ListResourcesIn): Promise<ListResourcesOut>;
  DeleteResource(request: DeleteResourceIn): Promise<Empty>;
  AssignRole(request: AssignRoleIn): Promise<Empty>;
  RevokeRole(request: RevokeRoleIn): Promise<Empty>;
  GrantPerm(request: GrantPermIn): Promise<Empty>;
  RevokePerm(request: RevokePermIn): Promise<Empty>;
  CreateTuple(request: Tuple): Promise<Empty>;
  ListTuples(request: ListTuplesIn): Promise<ListTuplesOut>;
  DeleteTuples(request: TupleFilter): Promise<Empty>;
}

export const AuthzServiceServiceName = "authzpb.v1.AuthzService";
export class AuthzServiceClientImpl implements AuthzService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AuthzServiceServiceName;
    this.rpc = rpc;
    this.ListUsers = this.ListUsers.bind(this);
    this.UpdateUser = this.UpdateUser.bind(this);
    this.DeleteUser = this.DeleteUser.bind(this);
    this.CreateRole = this.CreateRole.bind(this);
    this.ListRoles = this.ListRoles.bind(this);
    this.UpdateRole = this.UpdateRole.bind(this);
    this.DeleteRole = this.DeleteRole.bind(this);
    this.CreateResource = this.CreateResource.bind(this);
    this.ListResources = this.ListResources.bind(this);
    this.DeleteResource = this.DeleteResource.bind(this);
    this.AssignRole = this.AssignRole.bind(this);
    this.RevokeRole = this.RevokeRole.bind(this);
    this.GrantPerm = this.GrantPerm.bind(this);
    this.RevokePerm = this.RevokePerm.bind(this);
    this.CreateTuple = this.CreateTuple.bind(this);
    this.ListTuples = this.ListTuples.bind(this);
    this.DeleteTuples = this.DeleteTuples.bind(this);
  }
  ListUsers(request: ListUsersIn): Promise<ListUsersOut> {
    const data = ListUsersIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListUsers", data);
    return promise.then((data) => ListUsersOut.decode(new BinaryReader(data)));
  }

  UpdateUser(request: UpdateUserIn): Promise<Empty> {
    const data = UpdateUserIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateUser", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  DeleteUser(request: DeleteUserIn): Promise<Empty> {
    const data = DeleteUserIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteUser", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  CreateRole(request: CreateRoleIn): Promise<Empty> {
    const data = CreateRoleIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  ListRoles(request: ListRolesIn): Promise<ListRolesOut> {
    const data = ListRolesIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListRoles", data);
    return promise.then((data) => ListRolesOut.decode(new BinaryReader(data)));
  }

  UpdateRole(request: UpdateRoleIn): Promise<Empty> {
    const data = UpdateRoleIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  DeleteRole(request: DeleteRoleIn): Promise<Empty> {
    const data = DeleteRoleIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  CreateResource(request: CreateResourceIn): Promise<Empty> {
    const data = CreateResourceIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateResource", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  ListResources(request: ListResourcesIn): Promise<ListResourcesOut> {
    const data = ListResourcesIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListResources", data);
    return promise.then((data) => ListResourcesOut.decode(new BinaryReader(data)));
  }

  DeleteResource(request: DeleteResourceIn): Promise<Empty> {
    const data = DeleteResourceIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteResource", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  AssignRole(request: AssignRoleIn): Promise<Empty> {
    const data = AssignRoleIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "AssignRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  RevokeRole(request: RevokeRoleIn): Promise<Empty> {
    const data = RevokeRoleIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokeRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  GrantPerm(request: GrantPermIn): Promise<Empty> {
    const data = GrantPermIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "GrantPerm", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  RevokePerm(request: RevokePermIn): Promise<Empty> {
    const data = RevokePermIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokePerm", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  CreateTuple(request: Tuple): Promise<Empty> {
    const data = Tuple.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateTuple", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  ListTuples(request: ListTuplesIn): Promise<ListTuplesOut> {
    const data = ListTuplesIn.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListTuples", data);
    return promise.then((data) => ListTuplesOut.decode(new BinaryReader(data)));
  }

  DeleteTuples(request: TupleFilter): Promise<Empty> {
    const data = TupleFilter.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteTuples", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
